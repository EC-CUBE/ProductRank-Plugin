<?php
/*
 * This file is part of EC-CUBE
 *
 * Copyright(c) 2000-2015 LOCKON CO.,LTD. All Rights Reserved.
 *
 * http://www.lockon.co.jp/
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

namespace Plugin\ProductRank\Repository;

use Doctrine\ORM\EntityRepository;
use Eccube\Entity\ProductCategory;

/**
 * ProductRank
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ProductRankRepository extends EntityRepository
{
    /**
     * @var \Eccube\Application
     */
    private $app;

    /**
     * ProductRankRepository constructor.
     * @param \Doctrine\ORM\EntityManager $em
     * @param \Doctrine\ORM\Mapping\ClassMetadata $class
     * @param \Eccube\Application $app
     */
    public function __construct($em, \Doctrine\ORM\Mapping\ClassMetadata $class, \Eccube\Application $app)
    {
        parent::__construct($em, $class);
        $this->app = $app;
    }

    /**
     * @param \Eccube\Entity\Category $Category
     * @return \Eccube\Entity\ProductCategory
     */
    public function findBySearchData(\Eccube\Entity\Category $Category = null) {
        if (empty($Category) || !$Category) {
            return null;
        }
        $qb = $this->_em->getRepository('\Eccube\Entity\ProductCategory')
            ->createQueryBuilder('pc');
        $qb
            ->select('pc,p,c')
            ->innerJoin('pc.Product', 'p')
            ->innerJoin('pc.Category', 'c')
            ->where($qb->expr()->eq('pc.Category', ':Category'))
            ->setParameter('Category', $Category)
            ->orderBy('c.rank', 'DESC')
            ->addOrderBy('pc.rank', 'DESC')
            ->addOrderBy('p.id', 'DESC');
        return $qb->getQuery()->getResult();
    }

    /**
     * @param \Eccube\Entity\ProductCategory $TargetProductCategory
     * @return bool
     */
    public function up(ProductCategory $TargetProductCategory) {
        $this->_em->getConnection()->beginTransaction();
        try {
            $rank = $TargetProductCategory->getRank();

            /** @var \Eccube\Entity\ProductCategory $ProductCategoryUp */
            $ProductCategoryUp = $this->_em->getRepository('\Eccube\Entity\ProductCategory')
                ->createQueryBuilder('pc')
                ->where('pc.rank > :rank and pc.category_id = :category_id')
                ->setParameter('rank', $rank)
                ->setParameter('category_id', $TargetProductCategory->getCategoryId())
                ->orderBy('pc.rank', 'ASC')
                ->setMaxResults(1)
                ->getQuery()
                ->getSingleResult();

            $TargetProductCategory->setRank($ProductCategoryUp->getRank());
            $ProductCategoryUp->setRank($rank);

            $this->_em->persist($TargetProductCategory);
            $this->_em->persist($ProductCategoryUp);

            $this->_em->flush();
            $this->_em->getConnection()->commit();

            return true;
        } catch (\Exception $e) {
            $this->_em->getConnection()->rollback();
            $this->_em->close();
            $this->app->log($e);
        }

        return false;
    }

    /**
     * @param \Eccube\Entity\ProductCategory $TargetProductCategory
     * @return bool
     */
    public function down(ProductCategory $TargetProductCategory) {
        $this->_em->getConnection()->beginTransaction();
        try {
            $rank = $TargetProductCategory->getRank();

            $ProductCategoryDown = $this->_em->getRepository('\Eccube\Entity\ProductCategory')
                ->createQueryBuilder('pc')
                ->where('pc.rank < :rank and pc.category_id = :category_id')
                ->setParameter('rank', $rank)
                ->setParameter('category_id', $TargetProductCategory->getCategoryId())
                ->orderBy('pc.rank', 'DESC')
                ->setMaxResults(1)
                ->getQuery()
                ->getSingleResult();

            $TargetProductCategory->setRank($ProductCategoryDown->getRank());
            $ProductCategoryDown->setRank($rank);

            $this->_em->persist($TargetProductCategory);
            $this->_em->persist($ProductCategoryDown);

            $this->_em->flush();
            $this->_em->getConnection()->commit();

            $status = true;
        } catch (\Exception $e) {
            $this->_em->getConnection()->rollback();
            $this->_em->close();
            $this->app->log($e);
        }
    }

    /**
     * @param integer $category_id
     * @param integer $product_id
     * @param integer $position
     * @return bool
     * @throws NotFoundHttpException
     */
    public function moveRank($category_id, $product_id, $position) {
        $ids = array('category_id' => $category_id, 'product_id' => $product_id);

        $repos = $this->_em->getRepository('\Eccube\Entity\ProductCategory');

        $this->_em->getConnection()->beginTransaction();
        try {
            // 自身のランクを取得する
            $ProductCategory = $repos->findOneBy($ids);
            if (!$ProductCategory) {
                throw new NotFoundHttpException();
            }
            $oldRank = $ProductCategory->getRank();

            // 最大値取得
            $qb = $repos->createQueryBuilder('pc');
            $max = $qb
                ->select($qb->expr()->max('pc.rank'))
                ->where($qb->expr()->eq('pc.category_id', $category_id))
                ->getQuery()
                ->getSingleScalarResult();

            // 更新するランク値を取得
            $newRank = $this->getNewRank($position, $max);

            // 他のItemのランクを調整する
            $ret = $this->moveOtherItemRank($newRank, $oldRank, $repos, $category_id);
            if ($ret) {
                // 他のランク変更がある場合のみ処理を行う
                $ProductCategory->setRank($newRank);
                $this->_em->persist($ProductCategory);
                $this->_em->flush();

                $this->_em->getConnection()->commit();
            }

            return true;
        } catch (\Exception $e) {
            $this->_em->getConnection()->rollback();
            $this->_em->close();
            $this->app->log($e);
        }

        return false;
    }

    /**
     * 指定した順位の商品から移動させる商品までのrankを１つずらす
     *
     * @param  int     $newRank
     * @param  int     $oldRank
     * @param  SC_Query  $objQuery
     * @param string $tableName
     * @param string $addWhere
     * @return boolean
     */
    public function moveOtherItemRank($newRank, $oldRank, $repos, $category_id)
    {
        $qb = $repos->createQueryBuilder('pc');
        $qb->update();
        $qb->where($qb->expr()->eq('pc.category_id', $category_id));
        if ($newRank > $oldRank) {
            //位置を上げる場合、他の商品の位置を1つ下げる（ランクを1下げる）
            $qb->set('pc.rank', 'pc.rank - 1');
            $qb->andWhere($qb->expr()->between('pc.rank', $oldRank + 1, $newRank));
        } elseif ($newRank < $oldRank) {
            //位置を下げる場合、他の商品の位置を1つ上げる（ランクを1上げる）
            $qb->set('pc.rank', 'pc.rank + 1');
            $qb->andWhere($qb->expr()->between('pc.rank', $newRank, $oldRank - 1));
        } else {
            //入れ替え先の順位が入れ替え元の順位と同じ場合なにもしない
            return false;
        }

        $qb->getQuery()->execute();
        return true;
    }

    /**
     * 指定された位置の値をDB用のRANK値に変換する
     * 指定位置が1番目に移動なら、newRankは最大値
     * 指定位置が1番下へ移動なら、newRankは1
     *
     * @param  int $position 指定された位置
     * @param  int $maxRank  現在のランク最大値
     * @return int $newRank DBに登録するRANK値
     */
    private function getNewRank($position, $maxRank)
    {
        if ($position > $maxRank) {
            $newRank = 1;
        } else if ($position < 1) {
            $newRank = $maxRank;
        } else {
            $newRank = $maxRank - $position + 1;
        }

        return $newRank;
    }
}
